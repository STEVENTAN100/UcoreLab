### Lab0.5

#### 练习1: 使用GDB验证启动流程

说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？要求在报告中简要写出练习过程和回答。

**答：** 加电后的几条指令开始于0x1000，

```assembly
0x1000: auipc	t0,0x0 # 将程序计数器（PC）的高 20 位偏移量设置为0x0，并将结果存储在寄存器 t0 中，这实际上是一个将全局地址的高位加载到寄存器的指令
0x1004:	addi	a1,t0,32 # 将寄存器 t0 的值加上立即数32，并将结果存储在寄存器 a1 中
0x1008:	csrr	a0,mhartid # 将 mhartid 寄存器的值读取到寄存器 a0 中，mhartid 寄存器是 RISC-V 多核处理器中的一个特殊寄存器，用于表示当前硬件线程的标识符
0x100c:	ld	t0,24(t0) # load double words，从地址为 t0 加上 24 的内存位置处加载一个双字（64 位）的值，并将结果存储在寄存器 t0 中，那个地址保存的数据就是0x80000000
0x1010:	jr	t0 # 无条件跳转到寄存器 t0 中存储的地址
```

完成了到0x80000000的跳转，进而转入OpenSBI的启动流程，继续跳转至0x80200000 (`kern/init/entry.S`），最终交由我们的内核程序执行。

### Lab1

#### 练习1：理解内核启动中的程序入口操作

阅读`kern/init/entry.S`内容代码，结合操作系统内核启动流程，说明指令`la sp, bootstacktop`完成了什么操作，目的是什么？`tail kern_init`完成了什么操作，目的是什么？

**答：** `la sp, bootstacktop`是修改栈指针寄存器 `sp` 为 *.data* 段的结束地址，由于栈是从高地址往低地址增长，所以高地址是栈顶；`tail kern_init`的`tail`相当于`call`，跳转到`kern_init`函数，意味着内核运行环境设置完成了，正式进入内核。

#### 练习2：完善中断处理 （需要编程）

在实验报告中简要说明实现过程和定时器中断中断处理的流程。

**答：** 实现过程：参见代码。

时钟中断的执行流为：`set_sbi_timer()`通过OpenSBI的时钟事件触发一个中断，跳转到`kern/trap/trapentry.S`的`__alltraps`标记 -> 保存当前执行流的上下文，并通过函数调用，切换为`kern/trap/trap.c`的中断处理函数`trap()`的上下文，进入`trap()`的执行流。切换前的上下文作为一个结构体，传递给`trap()`作为函数参数 -> `kern/trap/trap.c`按照中断类型进行分发(`trap_dispatch(), interrupt_handler()`)->执行时钟中断对应的处理语句，累加计数器，设置下一次时钟中断->完成处理，返回到`kern/trap/trapentry.S`->恢复原先的上下文，中断处理结束。

#### 扩展练习 Challenge1：描述与理解中断流程

回答：描述Ucore中处理中断异常的流程（从异常的产生开始），其中`mov a0，sp`的目的是什么？`SAVE_ALL`中寄存器保存在栈中的位置是什么确定的？对于任何中断，`__alltraps` 中都需要保存所有寄存器吗？请说明理由。

**答：** 以时钟中断为例，参见上题解答。

`mov a0，sp`的目的是将当前栈顶地址 `sp` 的值给到寄存器 `a0` ，这是因为在 riscv calling convention 中，规定 `a0` 保存函数输入的第一个参数，于是就相当于将栈顶地址传给函数 `trap` 作为第一个参数。

`SAVE_ALL`寄存器保存在栈中的位置通过`addi sp, sp, -36 * REGBYTES`指令预先分配栈帧来确定。

不需要，在恢复上下文的代码中，我们可以看到在恢复现场的时候，对于控制状态寄存器的四个寄存器`status`,`epc`,`badaddr`,`cause`只恢复了其中的`status`和`epc`寄存器。这主要是因为`badaddr`寄存器和`cause`寄存器中保存的分别是出错的地址以及出错的原因，当我们处理完这个中断的时候，也就不需要这两个寄存器中保存的值，所以可以不用恢复这两个寄存器。

#### 扩展练习 Challenge2：理解上下文切换机制

回答：在`trapentry.S`中汇编代码`csrw sscratch, sp; csrrw s0, sscratch, x0`实现了什么操作，目的是什么？`SAVE_ALL`里面保存了`stval`,`scause`这些CSR，而在`RESTORE_ALL`里面却不还原它们？那这样store的意义何在呢？

**答：** `sscratch`寄存器规定：若在中断之前处于 U 态(用户态)，保存的是内核栈地址；否则中断之前处于 S 态(内核态)，保存的是 0，所以第一条指令是一个用户中断，把栈顶地址`sp`赋给`sscratch`；`x0`为0不用保存，第二条指令将`sscratch`的值保存在`s0`中，并将`sscratch`清零，目的是如果嵌套中断出现时，中断向量知道该中断是来自内核态的。

第二问参见上题解答，store的意义在于内核的C代码部分会需要读取这些CSR。

#### 扩展练习Challenge3：完善异常中断

**答：** 参见代码。
